# 硬件和控制结构
分页和分段的在内存管理上实现了突破，它们不同于固定分区和动态分区，有如下新特点：

1. 进程使用逻辑地址访问内存，而非物理地址。逻辑地址运行时被动态转换为物理地址，这意味着进程不需要在意物理地址的变换，只需按照不变的逻辑地址访问即可。因此，进程可以在内存中随意移动，可以被操作系统换入换出且访问指令和数据不受影响。
2. 一个进程可以被划分成很多个段和页，这些块不需要连续地位于内存中。这消灭了外部碎片并减少了内部碎片的产生。

包含这两个特点，那么进程不需要所有页或所有段都在内存中。将新进程放入内存时，操作系统仅读取程序开始的几个块，进程执行中的任何时候都在内存的部分成为「常驻集」。
如果处理器访问一个不在内存中的逻辑地址，就会产生一个中断。操作系统将被中断进程设置为阻塞态，然后将该逻辑地址的块读入内存。为此，操作系统会产生一个 I/O 读请求，在执行磁盘 I/O 期间，操作系统可以调度另一个进程运行。一旦所需块被读入内存，则产生一个 I/O 中断，控制权交会操作系统，操作系统将被阻塞的进程设置为就绪态。
有两种方法提高系统的效率

1. 在内存中保留多个进程：对任意进程都只仅装入他的某些块到内存中，这样可以放入足够多的进程。并且，任意时刻这些进程都有一个处于就绪状态，这样就可以提高处理器效率。
2. 给进程使用的空间比内存空间还大：程序员开发可以不受限于内存，好像拥有一个巨大的内存。进程想要运行还是要被装入内存中，那么内存相应的被叫做实存。但是我们感受到的内存巨大，这是磁盘分配给我们的，被称之为虚存。
## 局部性和虚拟内存
这里要分析一下虚拟内存的可行性，这里主要是依靠局部性原理得出的。
因为进程的执行往往会局限在很小的一段程序中，而在虚拟内存的情境下，我们只需要读入一部分内存，而其他暂不适用的块不用读入，这样可以节省空间并且保留较多的进程在内存中。处理器不会空闲，处理效率也得到了提升。
但是还需要考虑一个问题，许多进程都位于内存中，如果需要读取一个新的进程的块到内存中，就需要换出之前的一块。这种操作太多，会导致被称为「系统抖动」的情况。处理器的大部分时间都用于交换块而不是执行进程程序。因此这需要很多算法来避免系统抖动，而这些算法许多都是基于局部性原理。
在一段时间内，整个程序的执行仅限于程序的某一部分，相应地，程序访问的存储空间也局限于某个内存区域。因此也可以合理推断，下一次访问的块也在附近，那么就不太可能会读入新的块，这样就可以避免系统抖动频繁发生。
## 分页
现在讲述基于虚拟内存的分页机制。这里和简单分页不同，我们可以只让几个页存在于进程中。由于一个进程可能只有一些页在内存中，因此页表项需要有一位 P 来表示它所对应的页是否在内存中。若在，则还有此页对应的页框。再介绍另一个控制位 M，表示相应页的内容从上一次装入内存中到现在是否已经改变。除此之外还有许多控制位。
如果通过页表访问内存，那么需要从虚拟地址转变为物理地址。虚拟地址由页号和偏移量组成，获取对应的页号从页表中找到对应的页框号，然后再在此页框起始地址上加上偏移量即可获得物理地址。
![1667142584(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667142590045-f1a70d23-68eb-4581-9ece-723c510d2e94.png#averageHue=%23e8e8e8&clientId=uaf43333f-0c18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=354&id=ua9d4fd1e&margin=%5Bobject%20Object%5D&name=1667142584%281%29.png&originHeight=442&originWidth=739&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219319&status=done&style=none&taskId=u97fb2287-6101-4a55-90ef-f36ab70cdbc&title=&width=591.2)

现在还需考虑页表项过大的问题。假设我们采用 32 位地址，那么最终可以表示 `2^32` 个地址。我们需要用页来表示地址，一页大小为 4KB（即能表示的地址个数）。那么 32 位地址就需要 `2^32 / 2^12 = 2^20` 个页。而进程需要记录所有「页 -> 页框」的映射。这就需要页表项了，现在有 `2^20` 个页，那就需要 `2^20` 个页表项。一个页表项占据 4 字节，于是一个进程储存所有页表项就需要 `2^22 Byte = 4MB`。假设有 100 个进程，那么就是 400MB 的内存消耗。这是不能够接受的，于是现代操作系统大多会将页表项放到虚拟内存中而非实际内存，这样只需要放入部分的页表项即可。
### 多级页表
一些处理器采用两级方案组织大型页表（多级页表），这类方案中有一个页目录，其中的每一项指向一个页表。
还是假设 32 位地址，之前是一级页表，那么就是前 20 位表示页号，后 12 位表示偏移量。现在我们需要将前 20 位的前 10 位作为一级页表，后十位作为二级页表。这样可以节省内存，假设现在进程的运行都在根页表的第一项所对应的物理地址中，那么后面的页表项都不需要被加载。我们只需要当前进程使用的那部分内存块就够了，这就是虚拟内存带来的好处。
![1667143480(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667143483467-31da9969-8d52-443a-9680-24814d47b1db.png#averageHue=%23e6e6e6&clientId=uaf43333f-0c18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ucd7ba8dd&margin=%5Bobject%20Object%5D&name=1667143480%281%29.png&originHeight=323&originWidth=673&originalType=binary&ratio=1&rotation=0&showTitle=false&size=129615&status=done&style=none&taskId=u9d1b3512-4c1c-4e88-8a5b-77463d08c8a&title=&width=538.4)
![1667144002(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667144007916-31db4dea-5719-4b0e-a1f4-a6f810efed70.png#averageHue=%23eaeaea&clientId=uaf43333f-0c18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=334&id=u52b361dc&margin=%5Bobject%20Object%5D&name=1667144002%281%29.png&originHeight=417&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230456&status=done&style=none&taskId=u4b851df6-a784-4080-b557-51e0ee1bef1&title=&width=620)
### 倒排页表
### TLB命中
每个虚存访问可能会引起两次物理内存访问，一次是取得相应的页表项，一次是根据此页表项得到的值取物理地址。如果是更多级的页表，那就需要更多次访问物理内存。因此我们需要为页表项引入一个高速缓存 TLB。
以后给定一个访问的虚拟地址，处理器首先查看此地址是否在 TLB 中（TLB命中），若命中则直接得到物理地址。否则，处理器根据页号在页表项中得到页框号，然后得到物理地址，处理器同时更新 TLB。该方案可以较大提升性能。
![1667144359(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667144362492-f473618a-c4d1-4b8b-b75f-31a2edc8495f.png#averageHue=%23e3e3e3&clientId=uaf43333f-0c18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=u730e646c&margin=%5Bobject%20Object%5D&name=1667144359%281%29.png&originHeight=427&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=242547&status=done&style=none&taskId=u8233b83b-4bd2-4ddb-a6df-e5a0551776a&title=&width=578.4)
![1667144391(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667144396855-f2aac5ee-7a63-4a21-a913-797fc41e5591.png#averageHue=%23e3e3e3&clientId=uaf43333f-0c18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=504&id=ue785396b&margin=%5Bobject%20Object%5D&name=1667144391%281%29.png&originHeight=630&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281760&status=done&style=none&taskId=u6a96f7d4-7378-41fd-a20b-6f4dc09f779&title=&width=502.4)
## 分段
分段允许程序员将内存看成由多个段组成，段的大小是不等且动态的。存储器访问以「段号 + 偏移量」的形式组成的地址。
这种组织于非段式地址空间相比有许多优点

1. 段式的组织可以应对不断增长的数据结构，我们将这种数据结构放到它自己的段中，操作系统可以扩大或缩小这个段。如果需要扩大的段在内存中，且内存无足够空间，那么就会将这个段移动到内存中更大的区域，或者将其换出。
2. 允许程序独立地更改或重新编译，而不要求整个程序集合重新链接和重新加载。
3. 有助于进程间共享，程序员可在段中设置数据表，供其他进程访问。
4. 有助于保护，一个段可以被构造成一个程序或者数据集，我们可以指定它地访问权限。

每个进程都有自己的段表，简单分段中是当此进程的所有段都被装入内存时，此进程会创建一个段表并装入内存。基于分段的虚拟内存则只需要一个进程的一部分段在内存中即可。因此，段表项中需要有一位表示此段是否在内存中。
段表的长度是可变的，因此不能在寄存器中保存，其必须在内存中。当一个进程运行时，有一个寄存器保存该进程段表的起始地址，虚拟地址中的段号索引进程的段表并找到该段在内存地址。用此地址加上偏移量得到实际物理地址。
![1667185431(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667185435413-e08e5940-7a7f-4c94-8822-cde6294f4dd5.png#averageHue=%23ebebeb&clientId=ue20ed92f-12ac-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=366&id=u6f3d0db6&margin=%5Bobject%20Object%5D&name=1667185431%281%29.png&originHeight=457&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=272159&status=done&style=none&taskId=uddb17926-5c84-47e3-b16c-23e2e5035f3&title=&width=622.4)
## 段页式
分页和分段都有其好处，分页可以消除外部碎片，且内部碎片较少。分段对程序员可见，可以处理变长数据结构且能保护模块。为了结合两种模式的优势，有的操作系统会采取段页式管理方式来管理内存，其特点为：

1. 段页式系统中，用户地址空间被程序员分成许多段，每个段依次划分为固定大小的页。
2. 从程序员角度看，逻辑地址仍然由段号和段偏移量组成。
3. 从操作系统角度看，段偏移量可以看作指定段的一个页号和偏移量。

![1667185185(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667185189250-7dd399fa-a5c7-4aa6-90b0-8efeaf48e16c.png#averageHue=%23ececec&clientId=ue20ed92f-12ac-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=377&id=FMnGY&margin=%5Bobject%20Object%5D&name=1667185185%281%29.png&originHeight=471&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=288587&status=done&style=none&taskId=u3c7a1f4d-f3b4-488f-a52c-5ce66078851&title=&width=644.8)



## 保护和共享
# 操作系统软件
## 读取策略
读取策略确定一个页何时取入内存，常用的两种方式时请求分页和预先分页。

1. 请求分页：只有当访问到某页中的一个单元时才将该页取入内存。
2. 预先分页：读取的页并不是缺页中断请求的页，这是提前一次性读取的页。如果一个进程的页被连续存储在磁盘中，那么一次性多读取几页的效率更高。

如果内存管理策略合适，那么会出现如下情况。当进程第一次启动时，会在一段时间内出现很多的缺页中断，当越来越多的页被读取进内存时，才会根据局部性原理减少缺页中断次数。
当进程第一次启动，可采用预先分页策略。这样可以避免多次缺页中断读取磁盘页。
## 放置策略

## 置换策略
在计划置换的页集中，选择换出哪一个页。这里有一些基本置换算法：

1. 最佳（OPT）置换算法
2. 最近最少使用（LRU）置换算法
3. 先进先出（FIFO）置换算法
4. 时钟置换算法

最佳置换算法（OPT）
选择置换下次访问间距最长的那些页，该算法可以导致最少的缺页中断。但是我们无法预测下一次访问哪些页，因此这只是一个完美设想。可以作为一个标准来衡量其他算法的性能。
最近最少使用置换算法(LRU)
最近最少使用算法置换内存中上次使用距当前最远的页，根据局部性原理，这也是最近最不可能访问到的页。
先进先出置换算法（FIFO）
将分配给进程的页框看作一个循环缓冲区。
## 驻留集策略

## 清除策略

## 加载控制

# Unix和Solaris内存管理（X）
# Linux内存管理
## Linux虚拟内存
## 内核内存分配

# Windows内存管理(X)
