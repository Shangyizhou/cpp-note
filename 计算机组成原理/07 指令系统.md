[TOC]

# 指令系统

## 机器指令

计算机就是连续执行每一条机器语句而实现自动工作的，人们习惯吧每一条机器语言的语句称为机器指令，而又将全部机器指令的集合称为机器的指令系统

### 指令的一般格式

指令由操作码和地址码组成

![image-20210519150833485](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519150833485.png)

**操作码**

操作码用来指明该指令所要完成的操作，如加法、减法等。通常，其尾数反映了机器的操作种类，也即机器允许的指令条数，如操作码占7位，则该机器最多包含128条指令

操作码的长度可以固定，也可以不固定

固定形式：

- 将操作码几种放在指令字的一个字段内，这种格式便于硬件设计，指令译码时间短，广泛应用于字长较大的、大中型计算机和超级小型计算机以及RISC

不固定的形式：

- 操作码长度不固定会增加指令译码和分析的难度，使控制器的设计复杂。通常采用扩展操作码技术，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519151636665.png" alt="image-20210519151636665" style="zoom:80%;" />

其中指令字长为16位，其中4位为基本操作码字段O怕，另有3个4位长的地址字段为A1、A2、A3

- 4位基本操作码若全部用于三地址指令，则有16条

**若采用扩展操作码技术**

1111作为扩展标志

- 操作码取4位，三地址指令最多有15条（1110，2的四次方减一）
- 操作码取8位，二地址指令最多有15条
- 操作码取16位，零地址指令为16条

可见操作码的位数随着地址数的减少而增加

**地址码**

地址码用来指出该指令的源操作数的地址、结果的地址以及下一条指令的地址

地址可以是主存的地址，也可以是寄存器的地址、甚至可以是I/O设备的地址

（1）四地址指令

![image-20210519153714785](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519153714785.png)

如果地址字段均指示主存的地址，则完成一条四地址指令，共需访问4次存储器（取指令一次，取两个操作数两次，存放结果一次）

完成操作（A1）OP（A2）-> A3

OP为操作码，A1为第一操作数地址，A2为第二操作数地址，A3为结果地址，A4为下一条指令地址

因为程序中指令顺序执行，而程序计数器PC既能存放当前欲执行指令的地址，又有计数功能，所以它能自动形成下一条指令的地址，这样可省去A4，表达更大的地址范围

（2）三地址指令

![image-20210519154116311](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519154116311.png)

完成操作（A1）OP（A2）-> A3

同上，仍是四次访问主存

机器在运行过程，没必要每次运算结果都存入主存，中间结果可以暂存CPU的寄存器（如ACG）中，这样又可以省去A3，表达更大的地址范围

（3）二地址指令

![image-20210519154246418](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519154246418.png)

完成操作（A1）OP（A2）-> A1 A1既代表源操作数的地址，又代表存放本词运算结果的地址

这样子完成一条指令仍需访问4次存储器，如果完成（A1）OP（A2）->ACC 只需访问三次内存

（4）一地址指令

若只将一个操作数的地址隐含在运算器的ACC中，则指令字中只需给出一个地址码

![image-20210519154641680](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519154641680.png)

完成一次指令只需两次访存

（5）零地址指令

零地址指令无地址码，例如空操作，停机这类指令只有操作码，而子程序返回（RET）这类指令没有地址码，其操作数的地址隐含在堆栈指针SP中

### 指令字长

- 指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数

- 不同机器的指令字长不同

早期计算机指令字长、机器字长和存储字长相等，因此访问某个存储单元，便可取出一条完整的指令或一个完整的数据

随着计算机发展，一台机器的指令系统可以采用位数不相同的指令，即指令字长是可变的。多字长指令要多次访问存储器才可能取出一条完整的指令，CPU速度下降，为了提高指令运行速度和节省存储空间，通常尽可能把常用的指令设计成单字长或短字长指令

## 操作数类型和操作类型

### 操作数类型

地址中常见的操作数类型有地址、数字、字符、逻辑数据等

### 数据在存储器中的存放方式

通常存放在存储器或寄存器中，寄存器的位数可反映机器字长，一般机器字长可取字节的1、2、4、8倍，便于字符处理

图中所示存储器存储字长为32位，可按字节、半字、字、双字访问

![image-20210520220345412](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520220345412.png)

![image-20210520220433570](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520220433570.png)

### 操作类型

**数据传送**

寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送

**算术逻辑操作**

加减乘除和逻辑运算（与或非），低档机只支持最基本的二进制加减、比较、求补，高档机支持浮点运算和十进制运算

**移位**

算术移位、逻辑移位、循环移位

**转移**

无条件转移、条件转移、跳转、过程调用与返回、陷阱

无条件转移：不受任何条件约束，直接把程序转移到下一条需执行指令的地址

条件转移：根据当前指令的执行结果决定是否需要转移

调用与返回：具有特定功能的程序段可能会被反复使用，避免重复编写，把程序段设定为独立子程序，需要执行子程序时，只需用子程序调用指令即可

陷阱与陷阱指令：陷阱是一种意外事故的中断，意外发生，计算机发出陷阱信号，暂停当前程序的执行，计算机的陷阱指令一般不提供给用户直接使用，而作为隐指令

**输入输出**

**其他**

## 寻址方式

寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法

分为指令寻址和数据寻址两种

### 指令寻址

分为顺序寻址和跳跃寻址两种

顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址。跳跃寻址则通过转移类指令实现

![image-20210520221416212](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520221416212.png)

### 数据寻址

种类较多，必须设一字段来指明属于哪一种寻址方式

指令的地址码字段通常不代表操作数的真实地址，把它称为形式地址，记作A。操作数的真实地址称为有效地址，记作EA，它是由寻址方式和形式地址共同确定的

![image-20210520222137373](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520222137373.png)

**立即寻址**

操作数本身设置在指令字内，即形式地址A不是操作数的地址，而是操作数的本身，又称为立即数。数据采用补码形式存放，`#`表示立即寻址特征标记

![image-20210520222258527](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520222258527.png)

优点：取出指令就可以立即获得操作数，指令在执行阶段不必再访问存储器

**直接寻址**

指令字中的形式地址A就是操作数的真实地址EA

![image-20210520222418241](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520222418241.png)

优点：寻找操作数简单，不需要专门计算操作数的地址，指令执行阶段对主存只访问一次

缺点：A的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址

**隐含寻址**

指令字中不明显给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中

如下的图，只给出一个操作数的地址A，另一个隐含在累加器ACC中，累加器ACC成了另一个数的地址

![image-20210520222707802](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520222707802.png)

**间接寻址**

指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元的地址

![](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520224223239.png)

多次简介寻址时，可用存储字的首位来标志间接寻址是否结束，当存储字首位为1时，还需继续访存寻址

优点：

- 与直接寻址比，扩大了操作数的寻址范围，因为A的位数通常小于指令字长，而存储字长可与指令字长相等
- 便于编制程序，用间接寻址方便子程序的返回

![image-20210520224913939](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520224913939.png)

**寄存器寻址**

在寄存器寻址的指令字中，地址码字段直接指出了寄存器的编号，即EA=Ri

操作数不在内存中，寄存器寻址在指令执行阶段无需访存，减少了执行时间

只需指明寄存器编号，指令字较短，节省了存储空间

![image-20210520225111950](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520225111950.png)

**寄存器间接寻址**

Ri的内容不是操作数，而是操作数所在主存单元的地址号

需访问内存，但只需访问一次，比间接寻址少了一次

![image-20210520225226609](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520225226609.png)

**基址寻址**

基址寻址设有基址寄存器BR，其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容相加

![image-20210520230038349](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520230038349.png)可分为隐式和显示两种，左边为隐式

**隐式：**指在计算机内专门设有一个基址寄存器BR，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基质寻址即可

**显示：**在一组通用寄存器里，由用户明确指出哪个寄存器用作基址寄存器，存放基地址

**优点：**

基质寻址可以扩大操作数的寻址范围，因基质寄存器的位数可以大于形式地址A的位数

主存容量较大时，使用直接寻址，受A的位数限制，无法对主存所有单元进行访问，采用基质寻址就可

**例如：**将主存空间分为若干段，每段首地址存于基址寄存器中，段内的位移量由A指出，这样操作数的有效地址就等于基址寄存器内容与段内位移量之和，只要对基址寄存器的内容作修改，便可访问主存的任一单元

基址寻址在多道程序中很有用，用户不必考虑自己的程序存于主存的哪一空间，完全可由操作系统或管理程序根据主存的使用情况，赋予基址寄存器内一个初始值，便可将用户程序的逻辑地址转化为准村的物理地址

**变址寻址**

与基址寻址极为相似，其有效地址EA等于指令字中形式地址A与变址寄存器IX的内容相加之和

![image-20210520230149284](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520230149284.png)

基址寻址和变址寻址即为相似，但使用场景不同

基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序来确定，在程序中执行其值是不可变的，而指令字中的A是可变的

变址寻址中，变址寄存器中的内容由用户设定，在执行过程中可变，而指令字中的A是不可变的。变址寻址主要用于解决数组问题，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可以很容易形成数组中的任一数据的地址，特别适合编制循环程序

![image-20210520230629889](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520230629889.png)

**相对寻址**

相对寻址的有效地址是将程序计算机PC的内容与指令字中的形式地址A相加而成

![image-20210520230735594](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210520230735594.png)

相对寻址通常被用于转移类指令，转移后的目标地址和当前指令有一段距离，称为相对位移量。

相对寻址最大特点是转移地址不固定，可随PC值的变化而变化，因此，无论程序在主存的哪段区域，都可正常运行，对于编写浮动程序特别有利

**堆栈寻址**

堆栈寻址要求计算机设有堆栈，堆栈既可以用寄存器组来实现，也可利用主存的一部分来作堆栈