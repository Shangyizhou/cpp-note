[TOC]

# 计算机的运算方式

## 无符号数和有符号数

计算机中参与运算的数有两大类，无符号数和有符号数

### 无符号数

- 计算机中的结果都放在寄存器中，通常称寄存器的位数为机器字长

- 无符号数，即没有符号的数，在寄存器中每一位都可以用来存放数值，当存放有符号数时，则需流出位置存放符号

- 所以，机器字长相同情况下，无符号数和有符号数的对应数值范围不同
- 机器字长为16位，无符号数表示0~65535，有符号数表示-32768~+32768

### 有符号数

**机器数与真值**

一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

**那么，这里的 00000011 和 10000011 就是机器数。**

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，**将带符号位的机器数对应的真正数值称为机器数的真值**

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210517123151875.png" alt="image-20210517123151875" style="zoom: 80%;" />

**原码**

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
$$
[+1]_原 = 0000 0001
$$

$$
[-1]_原 = 1000 0001
$$

原码的0有两种形式
$$
[+0.0000]_原=0.0000
$$

$$
[-0.0000]_原 = 1.0000
$$

**反码**

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
$$
[+1] = [00000001]_原 = [00000001]_反
$$

$$
[-1] = [10000001]_原 = [11111110]_反
$$

**补码**

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
$$
[+1] = [00000001]_原 = [00000001]_反 = [00000001]_补
$$

$$
[-1] = [10000001]_原 = [11111110]_反 = [11111111]_补
$$

**变形补码**

即用两个二进制位来表示数字的符号位，其余与补码相同。变形补码，用“00”表示正，用“11”表示负，也称为模4的补码。用变形补码进行加减运算时，当运算结果的符号位出现“01”或者“10”时，则表示产生溢出。变形补码的最高位（第一个符号位）总是表示正确的符号，比如"00"、 “01”分别表示正数、正溢出（上溢），"11"、“10”表示负数、负溢出（下溢）

**移码**

补码与移码只差一个符号位。
对一个数补码的符号位取反得到该数的移码；对一个数移码的符号位取反得到该数的补码
$$
[x]_移 = 2^n+x
$$

**为何要使用原码, 反码和补码**

在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

> [+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

> [-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

> 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

> (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

转载自

https://www.cnblogs.com/zhangziqiu/

## 数的定点表示和浮点表示

计算机中，小数点不用专门的器件表示，而是按约定的方式标出，公有两种方分表示小数点

- 定点表示，定点表示的数称定点数
- 浮点表示，浮点表示的数称浮点数

### 定点表示

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210517144948963.png" alt="image-20210517144948963" style="zoom:80%;" />

- 小数点位于数符和第一数值之间时，机器内的数位纯小数
- 小数点位于数值位之后时，机器内的数为纯整数
- 定点机后，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”

### 浮点表示

小数点位置可以浮动的数，以下为公式
$$
N = S\times r^j
$$

- `r` 为阶数
- `S`为尾数
- `j`为阶码

**浮点数的表示形式**

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518135823357.png" alt="image-20210518135823357" style="zoom:80%;" />

浮点数由阶码`j`和尾数`S`两部分组成，阶码是整数，阶符和阶码的位数`m`合起来反映浮点数的表示范围和小数点的实际位置

尾数是小数，其位数`n`反映了浮点数的精度，尾数的符号`S_f`代表浮点数的正负

**浮点数的表示范围**

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518140503903.png" alt="image-20210518140503903" style="zoom:80%;" />

**浮点数的规格化**

提高浮点数的精度，其尾数必须为规格化数

基数为2时，尾数的最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1，尾数右移一位，阶码加1

基数为4时，尾数的最高位为2的数为规格化数。规格化时，尾数左移两位，阶码减1，尾数右移两位，阶码加1

基数为8时，尾数的最高位为3的数为规格化数。规格化时，尾数左移三位，阶码减1，尾数右移三位，阶码加1

### 浮点数和定点数的比较

- 浮点机和定点机中数的位数相同时，浮点数的表示范围比定点数的大得多
- 浮点数为规格化数时，其相对精度远比定点数搞
- 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤多，运算速度较低
- 在溢出的判断上，浮点数是对规格化数的阶码进行判断，定点数对数值本身进行判断，比如小数定点机中的数，其绝对值必须小于1，否则溢出，此时会停止运算。为了防止溢出，上机前必须选择比例因子，较为麻烦。而浮点数的表示范围比定点数大，仅当上溢时机器才停止运算，故一般不要求考虑比例因子的选择

### 计算案例

<img src="C:\Users\LENOVO\AppData\Local\Temp\WeChat Files\ca0b0539b099bfd740c99e2b8f6063f.png" alt="ca0b0539b099bfd740c99e2b8f6063f"  />

![0da79db21b0f05e25d7f46109f88d82](C:\Users\LENOVO\AppData\Local\Temp\WeChat Files\0da79db21b0f05e25d7f46109f88d82.png)

![08a9476e0e128e8eb0decba08564b37](C:\Users\LENOVO\AppData\Local\Temp\WeChat Files\08a9476e0e128e8eb0decba08564b37.png)

### IEEE754标准

现代计算机中，浮点数一般采用IEEE制定的国际标准，标准形式如下

![image-20210518142602189](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518142602189.png)

按IEEE标准，常用的浮点数有三种

![image-20210518142631090](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518142631090.png)

## 定点运算

包括移位、加、减、乘、除几种

### 移位运算

15m写成1500cm，1500相当于数15相对于小数点左移了两位，并在小数点前面添了两个0

- 左移n位，相当于该数字乘以10的n次方
- 右移n位，相当于该数字除以10的n次方

可以由10进制推广到2进制

移位运算符帮助计算机实现乘法的操作，在计算机没有乘除运算线路时，可以采用移位和加法相结合，实现乘除运算

**算数移位规则**

对于正数，因为
$$
[x]_原=[x]_补=[x]_反=真值
$$
故移位后出现的空位均以0添之

对于负数，由于原码、补码和反码不一样，所以机器数移位时，对其空位的填补规则不同

![image-20210518143943273](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518143943273.png)

- 机器数为正时，无论是左移还是右移，添补代码均为0（10左移100，乘上2的1次方）
- 由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可
- 由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，全添加1
- 分析负数的补码得，当其由低向高找到第一个1时，在此1左边的各位均与对应的反码相同，而在次1右边的各位均与对应的原码相同，故负数的补码左移时，空位出现在地位，则添补带啊吗与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添加1

**案例**

![f397e3cfa5eb879ecb26758b2c43566](C:\Users\LENOVO\AppData\Local\Temp\WeChat Files\f397e3cfa5eb879ecb26758b2c43566.png)

![6068adeadda19c272ae672bc2ce44c3](C:\Users\LENOVO\AppData\Local\Temp\WeChat Files\6068adeadda19c272ae672bc2ce44c3.png)

**算术移位和逻辑移位的区别**

有符号数的移位称为算术移位，无符号数的移位称为逻辑移位

寄存器内容为01010011，逻辑左移是10100110（无符号位，最高位0丢失），算术左移是00100110（符号位不动，最高位1丢失）

为了避免算术左移最高位丢失

![image-20210518145916706](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518145916706.png)

### 加法与减法运算

为解决减法转变加法的问题，现代计算机普遍采用补码进行加减运算

![image-20210518150845166](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518150845166.png)

![image-20210518150848530](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518150848530.png)

![image-20210518151211107](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518151211107.png)

**溢出判断**

（1）用一位符号位判断溢出

对于加法，只有在正数加正数或负数加负数情况下才会出现溢出

对于减法，只有在正数减负数或负数减正数情况下才会出现溢出

![image-20210518152325459](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518152325459.png)

- 对于1位符号位，用符号位产生的进位与最高有效位产生的进位进行异或操作后，按其结果判断

- 异或结果为1，则溢出（不同时成立）

- 异或结果为0，则无溢出（同时成立）

**案例**



![image-20210518152330473](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518152330473.png)

（1）用两位符号位判断溢出（变形补码）

用变形补码作加法时，2位符号位要连同数值部分一起参加运算，而且高位符号位产生的进位自动丢失便可得到正确结果

变形补码判断溢出的条件，当2位符号位不同时，表示溢出，否则，无溢出（01：正溢出、10：负溢出）

![image-20210518152858627](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518152858627.png)

![image-20210518152904020](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518152904020.png)

### 乘法运算

**笔算乘法**

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518153001650.png" alt="image-20210518153001650" style="zoom:80%;" />

- 4个位积一次相加，机器难以实现
- 乘积位数增长了一倍，造成器材的浪费和运算时间的增加

**笔算乘法的改进**

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518153120391.png" alt="image-20210518153120391" style="zoom:80%;" />

![image-20210518155728728](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518155728728.png)

![image-20210518155733430](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518155733430.png)

**以下来自王道考研**

![image-20210518155423999](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210518155423999.png)

乘法时候，拿末尾乘上面的数字

我们在纸上习惯左移写乘除法（下一次把被乘数往左边移动一位再乘），但实际在计算机上使用的是右移

算出每步的和并保存至累加寄存器（ACC），再增加下一次的（判断末位是1还是0，1则加上被乘数，0则加上0）

累加寄存器右移，移出的位进入了乘除寄存器里，乘除寄存器也右移一位（相当于更新末位，下一步是左边那一位和上面的相乘）

### 除法运算

略

## 浮点四则运算

$$
x = S_x \times\ r^j
$$



### 浮点加减运算

浮点加减运算步骤

- 对阶
- 尾数加减
- 规格化
- 舍入
- 判溢出

![image-20210519005018152](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519005018152.png)

用双符号位表示

X：11011，11.011000000 	

Y：11100，00.111011000

**1.对阶**

使两个数的阶码相等，小阶码向大阶码看齐，尾数每右移一位，阶码加1

阶码向大的看齐只会影响精度，但阶码向小的看齐，则左移，可能会影响尾数的符号位，到时候整个值都可能被影响
$$
0.1\times\ 10^2 + 0.01\times\ 10^3
$$
例如这个例子，我们需要将它们的阶码调到一致才可以相加
$$
0.01\times\ 10^3 + 0.01\times\ 10^3
$$
第一个数字的阶码加1，则前面的数字相对应除以10，这就对应了阶码加1和尾数右移

（1）求阶差：

因为是X-Y，所以减法变加法，需要将-Y转换为[-Y]的补码（连符号位一起取反加1），再与X相加

result = 11011 + 00100 = 11111 得-1，所以阶码要加1（X向Y看齐）

（2）对阶：

X：11011，11.011000000 -> 11100，11.101100000（尾数右移，阶码加1）

注：尾数右移，负数的补码左移添0，右移添1

**2.尾数加减**

[-Y]补 = 11100，11.0000101000（尾数连符号位一起取反加一）

![image-20210519103751056](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519103751056.png)

规格化之后再判断是否溢出

**3.规格化**

X-Y：11100，10.110001000 -> 11101，11.011000100（尾数右移，阶码加1）

![image-20210519104338204](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519104338204.png)

规格化后再判断是否溢出，再判断是否舍入，此时异或为0，没有溢出

**4.舍入**

![image-20210519104611091](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519104611091.png)

第一种容易造成进位，进位如果又溢出了还得继续舍入

**5.判溢出**

略

**强制类型转换**

![image-20210519104731503](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20210519104731503.png)

## 算术逻辑单元

略