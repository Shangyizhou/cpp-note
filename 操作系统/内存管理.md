# 对于内存管理的需求
操作系统对内存管理提出了五种需求：重定位、保护、共享、逻辑组织、物理组织。
## 重定位
多道程序设计系统，内存空间常常被多个进程共享。操作系统经常会将程序从内存中换入换出，如果程序下一次被换入内存时要求被换入到原来的位置，那么这将是内存管理一个很大的限制。因此，我们需要将进程重定位到不同区域。
操作系统负责管理内存，其会将进程换入或换出内存。处理器硬件和操作系统必须能够将内存访问转换成实际的物理内存地址。
## 保护
我们需要保证进程之间相互独立，进程之间不会互相干涉。因此，该进程以外的其他进程不能违规访问该进程的内存单元。我们无法预测该进程会访问的地址，程序动态运行时候可能访问了不该访问的地方。操作系统不能提前预防，它只能在运行使检查每个进程是否违规。
内存保护的需求需要由硬件来完成。
## 共享
多个进程之间可能会协同工作，共同访问一个内存空间，内存管理需要支持这种操作。
## 逻辑组织
内存总是被组织成线性的地址空间，地址空间由一系列字节或字组成。这不太符合编程时候所定义的结构，如果操作系统能够有效处理以某种形式组织的用户程序和数据（其实就是分段，分页组织地址），那么将带来如下好处：

1. 可以独立编写和编译模块，系统在运行时解析一个模块到其他模块的引用
2. 通过适度额外开销，可以给不同模块不同的保护级别（只读，只执行）
3. 可以引入机制，使得模块被多个进程共享。
## 物理组织
存储会分为内存和外存（磁盘存储）。内存提供快速访问，但是内存造价昂贵且容易丢失。大容量且可靠持久的存储还需靠外存。因此，需要两级存储。而操作系统就需要关注内存和外存之间的信息流组织。
# 内存分区
这里会介绍几种内存分区的方案，其中较为现代的虚拟内存方面会留到下一章节。其中，分区技术曾经用于许多过时的操作系统中，而分页和分段其实用到了虚拟内存。这里是不考虑虚拟内存的形式来提前介绍分页和分段，实际上并未使用过此方案。
![1666625872(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1666625884014-c8f05820-7cfb-4f65-b7bc-9d3d42b61298.png#averageHue=%23e5e5e5&clientId=u6b0ace6c-6e13-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=470&id=u028114f3&margin=%5Bobject%20Object%5D&name=1666625872%281%29.png&originHeight=588&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160344&status=done&style=none&taskId=ue64613d5-9b76-4900-b9df-32deba3d04c&title=&width=748.8)
## 固定分区
操作系统也是软件，其运行也需要内存。在大多数内存管理方案中，操作系统占据一部分固定内存，其余内存交给用户进程使用。管理用户进程的最简单方案就是将内存分成一个个区域，然后给进程使用。
我们可以按照分区大小分成两种情况考虑：使用大小相等的分区和使用大小不等的分区。
**使用大小相等的分区：**
小于或等于该分区的进程都可以装入到可用分区，如果有分区满了，就换出某个进程，将新的进程加入该分区。
**大小相等的分区难点：**

1. 程序可能太大而不能放到一个分区内。这种情况需要使用覆盖技术设计程序，即让任意时刻只让该程序的一部分出现在内存中，当需要其他部分的数据时，再将其加载进内存。
2. 内存的利用率很低，比如固定分成 8MB 分区，这时一个 2MB 的程序就会占据一个分区，然后白白浪费 6MB 的空间。这种属于内部碎片的产生，即一个分区没用被占满。

我们可以使用大小不相等的分区缓解这两个问题，这种分区更加灵活，比如其有 8MB 的分区，也有 4MB 的分区，也有 2MB 的分区。我们可以让小的分区来容纳小的程序，从而减少内部碎片的产生。
**放置算法：**
因为分区的大小都相等，所以可以将任意进程放入空闲的分区。
对于大小不相等的分区，有两种策略可以将进程分配到分区。

1. 将每个进程分配到能容纳它的最小分区，每个分区维护以调度队列，用于保存从这个分区换出的进程。这种方法可以使得每个分区内部浪费的空间最小（局部最优）。
2. 为所有进程只提供一个队列，当需要把一个进程装入内存时，选择可以容纳该进程的最小分区。如果所有分区都被占据，则必须进行交换。一般优先考虑换出能容纳新进程的最小分区中的进程。

固定分区方案相对简单，其存在如下缺点：

1. 分区的数目在系统生成阶段已经确定，限制了系统中活动进程的数目。
2. 分区的大小在系统生成阶段已经确定，小作业不能有效利用分区空间（内部碎片）。
## 动态分区
为了克服固定分区的缺点，后面提出了动态分区。对于动态分区，分区长度和数目是可变的。当进程被装入内存时，系统会给它分配一块和它所需容量完全相等的空间。
![1667099681(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667099687261-1622cfb6-a7fd-4fce-9b00-e47da70788df.png#averageHue=%23e4e4e4&clientId=u934d016f-50dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=uc55b837b&margin=%5Bobject%20Object%5D&name=1667099681%281%29.png&originHeight=517&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&size=303231&status=done&style=none&taskId=ua209f0f3-0cc4-467e-bf03-bd709246b31&title=&width=594.4)
随着时间推移，内存中产生了越来越多的外部碎片。外部碎片指的是连续的存储空间被分割成了一个个小碎片，无法连续起来应用。克服外部碎片的一种技术是压缩，操作系统不断移动进程，使得进程占用的空间连续。
**放置算法：**
当把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，则操作系统必须确定要为此进程分配哪个空闲块。

1. 最佳适配：选择与要求的大小最接近的快
2. 首次适配：从头开始扫面内存，选择大小足够的第一个可用块
3. 下次适配：从上一次防止的位置开始扫描内存，选择下一个大小足够的可用块

**三种算法的优缺点：**

1. 首次适配算法最简单，并且通常也是最好且最快的。但另一方面，首次适配算法往往会使得内存的前端出现很多小的空闲分区，每当需要进行首次适配算法的时候，就需要从遍历这些分区。
2. 下次适配算法通常比首次适配算法的结果差，它常常在内存的末尾分配空间，这将导致位于存储空间末尾的最大空闲内存块很快被分割成一个个小碎片。因此使用下次适配算法往往需要更多次的压缩空间。
3. 最佳适配算法的性能通常是最擦汗的，它需要查找满足的最小块，但结果却使得内存中很快产生许多很小的块。外部碎片的增多导致不能满足稍大点的内存分配，因此它需要更多的内存压缩。
## 伙伴系统
固定分区方案限制了进程的数目，动态分区的维护特别复杂，且压缩内存的操作增加了额外开销。而伙伴系统是另一种折中方案。
在伙伴系统中，可用内存块的大小为 `2^k` 个字，`L <= K <= U`

1. `2^L` 表示分配的最小块的尺寸
2. `2^U` 表示分配的最大块的尺寸，通常其代表可供分配的整个内存的大小

伙伴系统是如何分配内存的，其实可以理解为从中间切一刀：

1. 开始可用内存空间看作 `2^U`，如果请求的内存大小 s 在 `2^(U-1) < s <= 2^U` 范围内，则分配整个空间，否则该块被分成两个大小相等的伙伴。
2. 如果 s 在 `2^(U-2) < s <= 2^(U-1)`，则直接将分割的块分出来一份作为内存。否则，仍需挑出一块继续切割。
3. 持续这种操作，知道分出合适的块。

![1667100589(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667100590930-10652920-5539-4034-aea5-d23e875d5f85.png#averageHue=%23c6c6c6&clientId=u934d016f-50dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=u5bc8a53d&margin=%5Bobject%20Object%5D&name=1667100589%281%29.png&originHeight=557&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=521463&status=done&style=none&taskId=u69e25fef-bd22-4999-ba7c-1335f442b6f&title=&width=649.6000366210938)
伙伴系统可以表示为一个树
![1667100657(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667100658593-df14d29b-34d7-4090-a5c9-a57354156c82.png#averageHue=%23eeeeee&clientId=u934d016f-50dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u27e5cbcb&margin=%5Bobject%20Object%5D&name=1667100657%281%29.png&originHeight=430&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183470&status=done&style=none&taskId=u12293feb-bbea-4dcd-9ed1-a1ce3e8539a&title=&width=573.6)
## 重定位
上述的固定分区、动态分区和伙伴系统，都需要重定位功能。对于大小相等的分区以及只有一个进程队列的大小不等的分区，一个进程在它的生命周期内可能占据不同的分区。其被换出再换入时，可能会被放置到不同的分区。
动态分区也是类似的情况，并且动态分区还有压缩的操作，进程会在内存中被再次移动。因此，进程访问的指令和数据的位置是不固定的，当进程在内存中移动时，指令和数据单元的位置也会发生移动。
进程使用逻辑地址访问，逻辑地址会被转换为物理地址。比如，我们使用相对地址（逻辑地址的一种）访问数据，通过公式「物理地址 = 基址地址 + 相对地址」得到物理地址。这样，进程的移动只需要改变基址地址就行了，相对地址是不变的。这样就可以一直使用不变的相对地址去访问指令和数据了。
因此，分成逻辑地址和物理地址是方便内存管理的。
![1667104172(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667104172619-8d511970-73af-4019-9e2d-f7fbebb8255b.png#averageHue=%23e7e7e7&clientId=u8ea46f12-ca0a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=382&id=u714c3cb7&margin=%5Bobject%20Object%5D&name=1667104172%281%29.png&originHeight=477&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=201624&status=done&style=none&taskId=ub3458940-6549-4a3b-90de-aab0b1f674d&title=&width=487.2)
# 简单分页
大小相等的固定分区会产生内部碎片，大小可变的动态分区会产生外部碎片（压缩技术可解决，但是开销大）。
为了解决或尽力减小这些影响，现在提出分页机制。将内存划分成大小相等的块，这个块的结构较小。且每个进程也被分成一个个大小相等的块，进程中称为页的块就可以对应到内存中的页框块。
使用分页技术可以减少内部碎片，因为分页块被设计的较小，最后会浪费的也只是一个页块的一部分大小。而现在不要求页块连续，因此可以随意使用不相邻的页块，这消灭了外部碎片。
下面给出分页操作案例
![1667115686(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667115690976-dded0e4b-b37e-4a14-80a7-64708f206d17.png#averageHue=%23e3e3e3&clientId=u8ea46f12-ca0a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=ubc7e0919&margin=%5Bobject%20Object%5D&name=1667115686%281%29.png&originHeight=572&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&size=309182&status=done&style=none&taskId=ufba1bc60-6a08-45d7-b113-6a0af8d6fa2&title=&width=453.8000183105469)

1. 内存需要加入进程 A，进程 A 需要占据四个页大小。
2. 内存需要加入进程 B，进程 B 需要占据三个页大小。
3. 内存需要加入进程 C，进程 C 需要占据四个页大小。
4. 内存需要加入进程 D，进程 D 需要占据五个页大小，但此时空闲页只有四个。这个时候需要换出某个进程，然后将其空出的位置提供给进程 D。

操作系统会为每个进程维护一个页表，页表给出了该进程的每一个页所对应的页框（物理地址）的位置。逻辑地址就由页号 + 偏移量所组成。比如设计一页的大小为 1KB，也就是 2^10。操作系统地址为 16 位，那么就可以被分成 2^16 / 2^10 = 2^6 个页，因此前 6 位表示页号，而后面十位表示偏移量。
简单分页类似于固定分区，内存和物理地址被分成了确切的大小，然后对应映射即可。不同的是，分页机制不要求页块是连续的，而固定分区不是。且分页机制的页块大小较小，内部碎片少。
![1667116244(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667116246283-d0fcfa43-8b89-4fe4-88f3-77c268c2d71e.png#averageHue=%23e5e5e5&clientId=u8ea46f12-ca0a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=u038a4447&margin=%5Bobject%20Object%5D&name=1667116244%281%29.png&originHeight=449&originWidth=702&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254801&status=done&style=none&taskId=ud829f4d8-92cd-46be-90d4-f9f4bd087a1&title=&width=561.6)
![1667116290(1).png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1667116295036-7510766f-eeaa-4819-9a96-66e40e87cdf0.png#averageHue=%23eaeaea&clientId=u8ea46f12-ca0a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=591&id=u7a47b335&margin=%5Bobject%20Object%5D&name=1667116290%281%29.png&originHeight=739&originWidth=716&originalType=binary&ratio=1&rotation=0&showTitle=false&size=378084&status=done&style=none&taskId=ue334660d-4977-47af-9217-20b4d2af2bb&title=&width=572.8)
# 简单分段
不考虑虚拟内存，采用简单分段技术，将程序和其他相关数据划分到几个不同的段中。段的长度有限制，段的大小不一定相同。不能超过这个限度。采用分段技术的逻辑地址由段号和偏移量组成。
每个进程都有一个段表，系统也会维护一个记录内存空闲块的表。每个段表项必须给出相应的段在内存中的起始地址，且必须指明段长度。进程处于运行状态，系统将其段表地址加载到寄存器中，内存管理硬件来使用这个寄存器。
以 n+m 位的地址作为例子，n 为段号，m 为偏移量

1. 提取段号 n，以这个段号为索引，在进程的段表中找到该段的起始地址（物理地址）
2. 提取偏移量 m，与这个段的长度作比较。如果偏移量更大，则此地址无效
3. 计算物理地址，物理地址 = 起始地址 + 偏移量

采用分段技术，进程将被分成许多个段，段的大小不必相等。当进程被调入时，它的所有段都被装入内存中，并建立一个段表。
