# 并发的原理
并发是在单处理器多道程序设计系统中，进程交替执行，表现出一种同时执行的特征。在多处理器系统中，不仅可以交替执行进程，而且可以重叠执行进程。
交替和重叠是两种完全不同的执行模式，但这两种技术都可以看作是并发的实例，并且它们都有相同的问题。我们很难预测进程的执行速度，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略，并会带来以下困难

1. 全局资源共享充满危险性质，两个进程共享全局变量，那么进程对该变量的读写执行顺序非常关键
2. 操作系统很难对资源进行最优化分配。如果进程 A 获取一个 I/O 通道资源，但在使用资源前被挂起，倘若在这期间别的进程也无法使用这个资源，那么是非常低效的设计。并可能导致死锁。
3. 比较难定位程序设计错误，因为结果通常是不确定的且不可再现
# 进程间共享造成的问题
比如下面这个例子，运行 echo 程序，输入一个字符并保存到 chin 变量中，再赋给 chout 变量，最后输出 chout 变量的值到屏幕上。
```c
void echo()
{
    chin = getchar();
    chout = chin;
    putchar(chout);
}
```
如果是单处理器多道程序设计系统，进程之间可以切换，每个程序都需要使用这个 `echo`，所以这相当于是一个共享过程，但这会带来一些问题。
## 运行过程

1. 进程 A 调用程序，并在 getchar 返回值并将此值存储于 chin 之后立即中断，此时最近输入的字符 x 被保存在变量 chin 中
2. 进程 B 调用程序，输入值且程序正常运行，最后输出结果 y
3. 进程 A 恢复，此时 chin 里面的值 x 已经被 y 覆盖。最后输出了 y

造成以上原因是因为 B 进程影响了 A 进程的活动。如果在这个执行的过程中只能有一个进程，其他进程不能打断干扰就好了。
## 竞争条件
像这样的场景，我们称为竞争条件。竞争条件发生在多个进程或线程读写数据时，其最终结果依赖于多个进程的指令执行顺序。
## 对于并发，操作系统需要关注以下问题

1. 操作系统能记住各个活跃进程
2. 操作系统必须为各个活跃进程分配和释放各种资源，其中资源包括 
   - 处理器时间
   - 存储器
   - 文件
   - I/O 设备
3. 操作系统必须保护每个进程的数据和物理资源，避免其他进程的干扰
4. 一个进程的功能和输出结果必须与执行速度无关
# 实现互斥的方法
以下将讨论实现互斥的几种硬件方法
## 中断禁用
单处理器机器中，并发进程不能重叠，只能交替。且一个进程只能一直运行，直到它调用了一个系统服务或被中断。因此保证互斥，只需要保证一个进程不被中断即可。
这种能力可通过系统内核为启用和禁用中断定义的原语来提供。
```c
while (true)
{
    /* 禁用中断 */;
    /* 临界区域 */;
    /* 启用中断 */;
    /* 其余部分 */;
}
```
临界区不可被中断，所以保证了互斥，即只有一个进程可以在临界区。
**缺点**

- 代价高，处理器被限制于交替执行程序，效率降低
- 不能用于多处理器结构，有可能进程并行访问。（我们的禁用中断是针对于单处理器中断进程进行调度的场景）
## 专用机器指令
在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。基于这点，处理器设计出一些机器指令，用于保证两个动作的原子性。 **如在一个取指令周期中对一个存储器单元的读和写或者读和测试。** 在该指令执行过程中，其他指令访问该内存将被阻止，而且这些动作在一个指令周期内完成。
比较和交换指令（CAS算法）
```c
int compare_and_swap(int *word, int testlevel, int newval)
{
    int oldval;
    oldbal = *word;
    if (oldval == testval)
        *word = newval;
    return oldval;
}
```
```c
const int n = /* 进程个数 */;
int bolt;
void P(int i)
{
    while (true) {
        while (compare_and_swap(bolt, 0, 1) == 1) {}
        /* 临界区 */;
        bolt = 0;
        /* 其余部分 */;
    }
}

void main()
{
    bolt = 0;
    parbegin(P(1), P(2), ... , P(n));
}
```
查看上面的比较指令，进程就是通过上面的 `compare_and_swap` 获取进入临界区的权利。
`bolt` 是一个共享变量，初始化为 0，最先发现 `bolt` 值为 0 的那个进程才可以进入临界区，而其他进程只能忙等待。当一个进程离开临界区时，它将 `bolt` 值重新设置为 0，好让其他进程访问。

1. 我们的程序启动了好多个进程，然后某个进程执行 `compare_and_swap` 程序。
2. 此时 `bolt = 0`，与测试值相同，更改为新值 1 并返回旧值 0。因此，它会跳出 `while` 循环进入临界区。
3. 此时其它进程进入 `compare_and_swap`，但是 `bolt = 1`，不会更新内存，并返回旧值 1，因此会一直满足 `while` 的条件，一直无谓的忙等待着。
4. 第一个进程执行完了临界区的代码，它设置 `bolt = 0`，然后退出（这样忙等待的某个进程就可以跳出循环了）

**机器指令方法的优点**

- 适用于在单处理器或共享内存的多出力上的任何数目的进程
- 非常简单且易于证明
- 可用于支持多个临界区

**机器指令方法的缺点**

- 使用了忙等待：一个进程等待进入临界区时，它会持续消耗处理器时间
- 可能饥饿：某个进程可能一直等待进入临界区，而一直没被选中（因为进程的选择是任意的）
- 可能死锁：进程 A 进入临界区执行，但是处理器觉得它优先级低，将处理器给了优先级更高的进程 B，但是进程 B 因为进程 A 一直在临界区中，所以阻塞等待进程 A。这就造成了 A 等待 B，B 等待 A 这样循环等待的结果，造成了死锁。（因为我们不是使用禁用中断的方式实现的，所以仍然可能会发生中断然后切换进程）
# 提供并发性的程序设计语言机制
下面将讨论用于提供并发性的程序涉及语言机制。
## 信号量
基本原理：两个或多个进程可以通过信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。为了发信号，需要使用信号量这个特殊变量。

- 进程执行原语 `semSignal(s)`，进程通过信号量 s 发送信号。
- 进程执行原语 `semWait(s)`，进程通过信号量 s 接收信号。若信号没接收到，则进程一直挂起。

可以把信号看作一个整型变量，使用如下三种方法操作信号量。

- 一个信号量可以被初始化成非负数
- `semWait` 操作使信号量减 1。如果值变成负数，则执行 `semWait` 的进程被阻塞，否则进程继续执行。
- `semSignal` 操作使信号量加 1。如果值小于或等于 0，则某个被 `semWait` 操作阻塞的进程被解除阻塞。

信号量原语定义
```c
struct semaphore {
    int count;
    queueType queue;
};

void semWait(semaphore s)
{
    s.count--;
    if (s.count < 0) {
        /* 把当前进程插入到队列当中 */
        /* 阻塞当前进程 */
        
    }
}

void semSignal(semaphore s)
{
    s.count++;
    if (s.count <= 0) {
        /* 把进程P从队列当中移除 */
    	/* 把进程P插入到就绪队列 */
    }
}
```
二元信号量原语的定义
```c
struct binary_semaphore {
    enum{zero, one} value;
    queueType queue;
};

void semWaitB(binary_semaphore s)
{
    if (s.value == one)
        	s.value = zero;
    else {
        /* 把当前进程插入到队列当值 */
        /* 阻塞当前进程 */
    }
}

void semSignalB(semaphore s)
{
    if (s.queue is empty())
        s.value = one;
    else {
        /* 把进程P从队列当中移除 */
        /* 把进程P插入到就绪队列 */
    }
}
```

- 一个二元信号量的值只能初始化 0 或 1
- semWaitB 操作检查信号量的值，如果值为 0，那么进程执行 semWaitB 受阻。如果值为 1，那么将值改为 0，并且继续执行
- semSignalB 操作检查是否有进程在该信号上受阻，如果有，则唤醒进程。如果没有进程受阻，则将值设置为 1

**信号量和二元信号量特定**

- 非二元信号量常被称作计数信号量
- 二元信号量更好实现，与其相关的一个概念使互斥量。两者关键区别在于为互斥量加锁解锁的进程必须是同一个进程
- 无论是计数信号量还是二元信号量，都需使用队列保存在信号量上等待的进程。
### 使用信号量解决互斥
```c
const int n = /* 进程数 */
semaphore s = 1;
void P(int i)
{
    while (true) {
        semWait(s);
        /* 临界区域 */;
        semSignal(s);
        /* 其他部分 */;
    }
}

void main()
{
    parbegin(P(1), P(2), ... , P(n));
}
```

- 信号量被初始化为 1，第一个执行 `semWait` 的进程会将信号量值减一，然后进入临界区
- 此时别的进程执行到 `semWait` 是就会被阻塞，因为该信号量的值会继续减一，那么就会负数，因此进程会被阻塞并被放入等待队列
- 等第一个进程离开临界区后，执行 `semSignal` 操作，信号量的值会增加一，那么会唤醒一个阻塞进程。将它从等待队列放出并置于就绪状态

我们也可以初始化信号量的值为其他数量，这个数量对应于我们希望进入临界区的进程数量。这样就可以一次让多个进程进入临界区，而超过这个数量的其他进程就会被阻塞并放入等待队列。任何时候，s.count 的值都可以被解释如下

- s.count >= 0：s.count 是可以执行 semWait(s) 且不被阻塞的进程数
- s.count < 0：s.count 的大小是挂起在 s.queue 队列中的进程数
### 生产者消费者队列
......
### 信号量的实现
semWait 和 semSignal 必须作为原子原语实现。实现问题的本质是互斥，即任何时候只能有一个进程可以用 semWait 或 semSignal 操作控制信号量。以下有两种可能的实现方式

1. 比较并交换指令
```c
semWait(s)
{
    while (compare_and_swap(s.flag, 0, 1) == 1)
        /* 不做任何事 */;
	s.count--;
    if (s.count < 0) {
        /* 把当前进程插入到队列当值 */;
        /* 阻塞当前进程 */;
    }
    s.flag = 0;
}

semSignal(s)
{
    while (compare_and_swap(s.flag, 0, 1) == 1)
        /* 不做任何事 */;
    s.count++;
    if (s.count <= 0) {
        /* 把进程P从队列当中移除 */;
        /* 把进程P插入到就绪队列 */;
    }
    s.flag = 0;
}
```
可以看到还是熟悉的 `compare_and_swap` 指令，但是增加了一个新的整形分量 `s.flag`。这里仍然用了忙等待的方法来实现，但是 semWait 和 semSignal 所涉及的时间比较短，所以可以接受。

2. 中断方式
```c
semWait(s)
{
    禁用中断;
    s.count--;
        if (s.count < 0) {
        /* 把当前进程插入到队列当值 */;
        /* 阻塞当前进程 */;
    }
    else 
        允许中断;
}
semSignal(s)
{
    禁用中断;
    s.count++;
    if (s.count <= 0) {
        /* 把进程P从队列当中移除 */;
        /* 把进程P插入到就绪队列 */;
    }
	允许中断;
}
```
