首先介绍进程的概念，讨论进程状态，进程状态描述了进程的行为特征。接着着眼于操作系统表示每个进程的状态所需要的数据结构。
# 什么是进程
# 进程的运行状态
## 最直白印象——运行和非运行
不考虑多种情况，直白的思考，在任何时刻，一个进程要么执行，要么没有执行，因此可以构造最简单的模型，运行态和未运行态。
当操作系统创建一个新进程时，它将该进程以未运行态加入到系统中，操作系统知道这个进程是存在的，但是其还未被执行。等操作系统中的分配器选择一个新进程时，它由未运行态转换到运行态。
从设计角度来看，操作系统需要跟踪这个进程，它要直到这个进程目前处于什么状态，知道这个进程在内存还是外存的哪个位置，它才方便将此进程转换到另一个状态。因此，我们需要有能够记录进程的信息的结构，即进程控制块。那么为了处理这些进程，我们可以创建一个等待队列用于保存未经处理的进程（保存指向进程的指针），然后这个队列一个个弹出元素给处理器。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1666351932476-14763d25-284b-4033-a939-c37dda57deee.png#averageHue=%23eeeeee&clientId=u6d32c2b3-b390-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u87d85802&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=661&originalType=url&ratio=1&rotation=0&showTitle=false&size=175855&status=done&style=none&taskId=u4d1afa79-2c9e-492b-bc83-582c23cbe3b&title=)
## 改进——进程的创建和终止
对于进程来说，其创建和终止的过程是十分重要的，我们引入「新建态」和「退出态」这两个状态来更加确切的表示进程的状态关系。
新建状态对应于刚刚定义的进程，操作系统可以分两步定义新进程。首先，操作系统执行一些辅助工作，将标识符关联到进程，分配和创建管理进程所需要的所有表。 **此时的进程处于新建状态，这意味着操作系统已经执行了创建进程的必须动作，但是还未执行进程。**
怎么理解加粗的这句话呢？比如，操作系统因为内存局限的原因，限制了进程的数量，所以没有执行进程。此时，虽然该进程相关的执行信息被记录在了内存的进程表中，但是该进程本身并未进入内存，就是即将执行的程序代码不在内存中，也没有为这个程序相关的数据分配空间。因此，进程处于新建态时，程序保留在外存中（通常是磁盘）。
类似的，进程退出系统也分为了两步，当一个进程自然结束时，进程被终止。 **终止使进程转换到退出态。** 此时进程不再被执行，与作业相关的表和其他信息临时被操作系统保存起来（有些程序可能还要获取这些信息，比如父进程回收子进程）。一旦这些程序获取了这些保存的信息，操作系统就不会再保留任何与该进程相关的信息，该进程从系统中删除。
## 初具雏形——五状态模型
倘若所有队列都处于就绪态，那么用之前的简单队列是有效的。我们对这些可运行的进程进行轮转策略即可，每个进程都只运行一个时间片，然后切换下一个进程。但是，进程队列中不可能都是就绪的进程，还有着一些处于阻塞状态等待 I/O 操作的进程。如果只使用单个队列，那么分派器只会考虑先进入的（最老的）进程，我们无法确保这个进程能不能执行。因此这种设计并不合理，它应该扫描整个队列，选出其中未被阻塞且在队列中时间最长的进程。
为此，我们继续引入两个状态，就绪态和阻塞态，于是就有了现在的五状态模型！
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1666351952196-7f69b55c-778a-4114-87f5-7b0d99cb4fc0.png#averageHue=%23ddeaf6&clientId=u6d32c2b3-b390-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u64e662d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=557&originWidth=1271&originalType=url&ratio=1&rotation=0&showTitle=false&size=42813&status=done&style=none&taskId=ue8e55509-0137-4ff7-8e46-55e2ef0c61f&title=)

- **新建态：** 进程刚创建时的状态，此时操作系统还未把它加入可执行进程组中。通常是进程控制块已经创建但还没有被加载到内存的新进程。
- **运行态：** 该进程正在执行，占据处理器。
- **就绪态：** 进程做好了准备，只要抢占到了处理器就可以执行。
- **阻塞态：** 进程在某些事情完成之前不可以执行，即使给它了处理器（比如请求 I/O 操作）。
- **退出态：** 操作系统从可执行进程组中释放出的进程。
## 考虑外存——挂起状态
之前的三种基本状态（就绪态、运行态和阻塞态）再加上新建态和退出态似乎足够我们描述一个进程的行为模式了，我们为什么还要增设一个挂起状态？
好，假设我们上述的结果都是在没有建立虚拟存储的情况下得到的，即我们的程序都是全部留在内存中的。我们的内存中会存在多个进程，当进程处理 I/O 事件时，处理器会在多个进程中切换，那么如果所有进程都执行 I/O 事件呢？这是很可能发生的事情，这个时候我们的处理器就会处于空闲状态，尽管我们已经不是单道程序设计了，但是我们大多数时候我们的处理器还是会处于空闲状态，这会让我们无法利用处理器资源。
我们也许会想，要不增加内存，来容纳更多的进程，这样所有进程都处理 I/O 事件的可能性就大大降低了，处理器就可以利用起来了。但是内存太贵了，这样不经济划算。
另一种解决方案就是交换了，将内存中某个进程的一部分或全部移到磁盘中，当内存中没有处于就绪状态的进程时，操作系统就会把被阻塞的进程换出到磁盘的挂起队列。之后，操作系统再换入一个进程或者接收一个新进程的请求，将其纳入内存执行。（注意，交换也是一个 I/O 操作）
因此，基于上述的内容，我们增设一个挂起态。考虑到进程是否在等待一个事件和进程是否已经被换出内存，需要四个状态表示

- **就绪态： ** 进程在内存中并可以执行
- **阻塞态：** 进程在内存中并等待一个事件
- **就绪/挂起态：** 进程在外存中，但只要被载入内存就可以执行
- **阻塞/挂起态：** 进程在外存中并等待一个事件
## 什么时候会挂起进程

- 交换 
   - 操作系统需要释放足够的内存空间，以调入并执行处于就绪状态的进程
- 其他 OS 原因 
   - 操作系统可能挂起一个程序的执行，或者被怀疑导致问题的进程
- 交互式用户请求 
   - 用户可能希望挂起一个程序的执行
- 父进程请求 
   - 父进程希望挂起子进程的执行，以检查或修改挂起的进程
# 如何去描述一个进程
操作系统控制计算机系统内部的事件，它为处理器执行进程而进行调度和分派，给进程分配资源，并响应用户程序的基本服务请求，因此可以把操作系统称为管理系统资源的实体。
那么操作系统为了控制和管理资源需要哪些信息？
## 操作系统的控制结构
操作系统为了管理进程和资源，必须掌握关于每个进程和资源当前状态的信息，操作系统会构造并维护它所管理的每个实体的信息表。一般来说，都会维护 4 种不同类型的表，内存、I/O、文件和进程。（尽管操作系统实现各不相同，但基本都可分为这 4 类）
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1666351864547-435a1f86-620b-4cd9-b03d-1e665b3691b0.png#averageHue=%23ececec&clientId=u6d32c2b3-b390-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=YpSbW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&size=126674&status=done&style=none&taskId=uffd435fc-f94f-4512-93b5-c79c905beab&title=)

- **内存表** 
   - 内存表用于跟踪内存和外存，其一般包含如下信息
   - 分配给进程的内存
   - 分配给进程的外存
   - 内存块或虚拟内存块的任何保护属性，如哪些进程可以访问某些共享内存区域
   - 管理虚拟内存所需要的任何信息
- **I/O表** 
   - 操作系统使用 I/O 表管理计算机系统中的 I/O 设备和管道
- **文件表** 
   - 这些表提供关于文件是否存在、文件在外存中的位置
- **进程表** 
   - 管理进程

这些表必须以某种方式链接起来或交叉引用。比如，内存，I/O、和文件是代表进程而被管理的，因此进程表中必须有对这些资源的直接或简洁引用。文件表中的文件可以通过 I/O 设备访问，有时它们也位于内存中或虚拟内存中，因此也受制于内存的管理。
## 进程控制结构
现在有一个问题，进程的物理表示是什么，或者说，进程应该包含着哪些信息？
我们常说，进程是运行的程序，那么进程肯定包含执行的程序（代码段，数据段之类），为了运行这个程序，我们需要将进程加载入内存，那么进程肯定也包含着内存相关的信息，比如记录程序在内存中的位置信息。而对于抽象的进程，每个进程也有着一些不同的属性，比如某个进程的权限等级，资源使用情况等。
所以总结一下，进程应有如下这些基本的信息。

- 进程应包含被执行的程序，与这些程序相关联的是局部变量、全局变量和任何已定义常量的数据单元。
- 进程需要有内存空间去保存程序和数据，进程的执行涉及过程调用中传递参数的栈。
- 进程有许多属性，这些属性的集合被称作进程控制块，而程序、数据、栈和属性集合称作进程映像。
## 进程属性
进程属性信息保存在进程控制块（PCB）中，大致可以把进程控制块信息分为三类

- 进程标识信息 
   - 此进程的标识符（PID）
   - 该进程父进程的标识符
   - 用户标识符（UID）
- 处理器状态信息 
   - 用户可见寄存器：处于用户态的处理器执行机器语言时可访问的寄存器
   - 控制和状态寄存器：程序计数器等
   - 栈指针：每个进程有一个或多个与之关联的系统栈，用户保存参数和过程调用的地址，栈指针指向栈顶
- 进程控制信息 
   - 调度和状态信息：操作系统执行调度功能所需信息
   - 数据结构
   - 进程间通信
   - 进程特权
   - 存储管理
   - 资源的所有权和使用情况
## 进程控制块作用
进程控制块（PCB）可以说是操作系统最重要的数据结构了，每个进程控制块都包含着相关进程的所有信息，而操作系统在涉及调度、资源分配、中断处理等操作时会经常读取修改这些信息。
操作系统可以通过进程的唯一 PID 来访问进程，PID 可以用作进程控制块指针表的索引。
# 进程控制
## 处理器的执行模式（用户态和内核态）
大多数处理器支持两种执行模式，即一部分敏感指令只能在内核态下执行，而另一部分不涉及敏感的指令在用户态中执行。
在内核态下执行得指令包括控制寄存器的指令，原始 I/O 指令和与内存管理相关的指令。而且还有部分内存区域仅在内核态下才能被访问。
使用两种执行模式可以保护操作系统和其所维护的一些列表不受用户程序的干涉。在内核态下，软件具有对处理器以及所有指令、寄存器和内存的控制能力。
进程往往会在运行时穿插于两种执行模式，比如用户态的进程想要完成一次 I/O 操作。但是 I/O 部分属于敏感指令，这就需要从用户态变成内核态。因此了解用户态和内核态的知识有利于我们理解进程的工作。
## 进程创建
操作系统创建进程的步骤：

1. 给新进程分配一个唯一的进程标识符
2. 给进程分配地址空间
3. 初始化进程控制块
4. 设置正确的链接
5. 创建或扩充其他数据结构
## 进程切换
### 何时会切换进程
**在发生系统中断和系统调用的情况下，操作系统会切换进程。**
先说系统中断，操作系统区分两种类型的系统中断

1. 中断：某种外部事件导致，与当前运行进程的行为无关，比如 I/O 操作。
2. 陷阱：与当前运行进程的行为有关，并且是进程运行产生了错误或异常，比如非法的文件访问，非法的内存访问。

对于普通中断，我们会先交给中断处理器来处理。它会先完成一些辅助操作，之后会交给特定的中断例程处理。比如时钟中断，I/O 中断，内存失效等特定例程。
对于陷阱，操作系统会判断造成此陷阱的错误或异常是否是知名的。如果是，则当前运行进程转换到退出态，并发生进程切换。如果不是，操作系统的处理行为取决于错误类型。
对于系统调用，比如一个用户进程正在运行，他要执行一条 I/O 相关的指令。而之前我们说过，这种敏感指令是需要在内核态下才能执行的。于是，操作系统会进行一些处理，转移到内核态下执行指令。而这个用户进程往往会被操作系统设置为阻塞态。
### 内核态和用户态切换
假设现在有一个中断需要处理，处理器会这么工作：

1. 把程序计数器设置成中断处理程序的开始地址（程序计数器保存下一条指令的地址）
2. 从用户态切换到内核态，使得中断处理代码可以包含含有特权的指令

程序计数器取出下一条指令执行程序，于是中断处理程序开始工作。此时，被中断的进程上下文保存在了该进程的进程控制块中。
这里需要解释一下，进程本来好好的运行，但是突然因为外部因素被中断了，此时会跳到中断处理程序，中断处理程序自然会处理好外部事情，到时候自然会切换回来继续执行。但是它怎么知道进程之后的任务是什么呢？它怎么知道要进程下一步执行的指令是什么呢？因此为了防止处理完程序后跑丢任务，发生中断时需要将进程的上下文保存到该进程的进程控制块中。
**简而言之，中断会破坏你原本的执行信息，于是我提前将这些信息保存到进程控制块中，防止回来后无法继续执行下去。**
一般来说，保存现场和恢复现场的功能由硬件实现。
### 进程状态改变的切换
之前讲解的是用户态和内核态的切换，举的例子是一个用户态进程因为执行敏感指令需要切换到内核态。这并不涉及到进程间的切换，也不会改变进程的状态。现在我们需要讲解一下进程 A 切换到进程 B 会发生的情况。

1. 保存处理器上下文环境，保存程序计数器和其他寄存器
2. 更新当前处于运行态进程的进程控制块，改变进程状态，更新相关数据。
3. 将进程控制块移动到相应的队列
4. 进程调度算法选择另一个进程执行
5. 更新所选择进程的进程控制块，将其设置为运行态
6. 更新内存管理的数据结构
7. 恢复被选择的进程的上下文环境，从其进程控制块中将之前存储的信息重新加载到寄存器，程序计数器中。

进程切换涉及到状态变换，需要比用户态和内核态的切换做更多工作。
# 操作系统的执行
...
# 参考
《操作系统精髓与设计原理》——富兰克林
